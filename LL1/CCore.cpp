//	CCore.cpp
//
//	CCore database object

#include "PreComp.h"
#include "Tags.h"

#define CORE_SIGNATURE							'CORE'
#define CORE_VERSION							1

#define INIT_BLOCKSIZE							1024
#define INIT_ENTRIES							128

char g_szSysCatCategory[] = "$Category";

CCore::CCore (void) : m_pDb(NULL),
		m_pUNID2Title(NULL),
		m_pTitle2UNID(NULL),
		m_pCategoryIndex(NULL),
		m_fHeaderModified(FALSE),
		m_fTitleIndexModified(FALSE),
		m_fCategoryIndexModified(FALSE),
		m_pCategoryList(NULL),
		m_pCC(NULL)

//	CCore constructor

	{
	}

CCore::~CCore (void)

//	CCore destructor

	{
	Close();
	}

ALERROR CCore::Close (void)

//	Close
//
//	Close the database

	{
	ALERROR error;

	if (m_pDb)
		{
		if (m_pCategoryList)
			delete m_pCategoryList;

		if (error = Flush())
			return error;

		if (error = m_pDb->Close())
			return error;

		delete m_pDb;
		m_pDb = NULL;

		delete m_pUNID2Title;
		m_pUNID2Title = NULL;

		delete m_pTitle2UNID;
		m_pTitle2UNID = NULL;

		delete m_pCategoryIndex;
		m_pCategoryIndex = NULL;

		delete m_pCC;
		m_pCC = NULL;
		}

	return NOERROR;
	}

ALERROR CCore::Create (CString sFilename)

//	Create
//
//	Create a new database

	{
	ALERROR error;

	//	Create the datafile

	if (error = CDataFile::Create(sFilename, INIT_BLOCKSIZE, INIT_ENTRIES))
		return error;

	//	Open the datafile

	CDataFile Db(sFilename);
	if (error = Db.Open())
		return error;

	//	Prepare a header

	COREHEADER coreheader;
	utlMemSet(&coreheader, sizeof(coreheader), 0);
	coreheader.dwSignature = CORE_SIGNATURE;
	coreheader.dwVersion = CORE_VERSION;

	//	Save it out

	CString sData((char *)&coreheader, sizeof(coreheader), TRUE);
	int iEntry;
	if (error = Db.AddEntry(sData, &iEntry))
		return error;

	//	Make the header the default entry

	Db.SetDefaultEntry(iEntry);

	//	Done

	if (error = Db.Close())
		return error;

	return NOERROR;
	}

ALERROR CCore::CreateGeneratedEntry (ENTRYUNID dwUNID, CEntry **retpEntry)

//	CreateGeneratedEntry
//
//	Creates a new entry generated by code in the given UNID

	{
	ALERROR error;
	CEntry *pEntry;
	CEntry *pNewEntry;
	ICCItem *pArg1;
	ICCItem *pArg2;
	ICCItem *pResult;

	//	Load the entry generator

	if (error = LoadEntryByUNID(dwUNID, &pEntry))
		return error;

	//	Create a new entry

	pNewEntry = new CEntry(this);
	if (pNewEntry == NULL)
		{
		delete pEntry;
		return ERR_MEMORY;
		}

	//	Set the title of the entry

	pNewEntry->SetTitle(strPatternSubst(LITERAL("Result of %s"),
			pEntry->GetTitle()));

	//	Set the category

#if 0
	pNewEntry->AddCategory(LITERAL("Reports"));
#endif

	//	The first argument is the new entry

	pArg1 = m_pCC->CreateInteger((int)pNewEntry);

	//	The second argument is the entry that is generating the code

	pArg2 = m_pCC->CreateInteger((int)pEntry);

	//	Run

	pResult = RunEntryCode(pEntry, LITERAL(GENERATOR_CODE_FIELD), pArg1, pArg2, NULL);

	//	If we got an error, replace the body text with the error code

	if (pResult->IsError())
		pEntry->SetBody(m_pCC->Unlink(pResult));

	//	Clean up

	pResult->Discard(m_pCC);
	pArg1->Discard(m_pCC);
	pArg2->Discard(m_pCC);
	delete pEntry;

	//	Make sure that the code is linked

	if (error = pNewEntry->CompleteLoad())
		return error;

	//	Add the new entry

	if (error = CreateNewEntry(pNewEntry))
		{
		delete pNewEntry;
		return error;
		}

	//	Done

	*retpEntry = pNewEntry;

	return NOERROR;
	}

ALERROR CCore::CreateNewEntry (CEntry *pEntry)

//	CreateNewEntry
//
//	Adds a new entry to the database. pEntry->m_dwUNID is set with the
//	new UNID.

	{
	ALERROR error;

	//	Set the creation and modification dates

	pEntry->SetCreation();

	//	First save the entry to XML

	CString sXML;
	if (error = CEntry::SaveToXML(pEntry, &sXML))
		return error;

	//	Now save to the database

	int iEntry;
	if (error = m_pDb->AddEntry(sXML, &iEntry))
		return error;

	//	Remember the entry ID

	pEntry->SetUNID((ENTRYUNID)iEntry);

	//	Make sure the code is linked

#if 0
	//	This code seems unnecessary because any entry
	//	that is passed-in will already have been loaded.
	if (error = pEntry->CompleteLoad())
		return error;
#endif

	//	Update the index

	UpdateCategoryIndex(pEntry, FALSE);
	UpdateTitleIndex(pEntry);

	//	Flush. Note that for efficiency we should do this on
	//	a background thread. For now, though, we do it synchronously.

	if (error = Flush())
		return error;

	return NOERROR;
	}

CString CCore::Deuniquify (CString sText, ENTRYUNID *retdwUNID)

//	Deuniquify
//
//	Reverses the Uniquify method

	{
	char *pPos;
	char *pStart;
	CString sResult;

	//	Search backwards for the open brace

	pStart = sText.GetPointer();
	pPos = pStart + sText.GetLength();
	while (*pPos != '<' && pPos != pStart)
		pPos--;

	//	The result is everything before the open brace

	sResult = strSubString(sText, 0, pPos - pStart);

	//	See if we want the UNID

	if (retdwUNID)
		*retdwUNID = (DWORD)strParseInt(pPos+1, (int)UndefinedUNID, NULL, NULL);

	return sResult;
	}

CString CCore::ExecuteCommand (CString sCommand)

//	ExecuteCommand
//
//	Executes a command

	{
	CString sOutput;
	ICCItem *pInput;
	ICCItem *pOutput;
	COREEXECCTX Ctx;

	//	Initialize context

	Ctx.pCore = this;

	//	Parse the input

	pInput = m_pCC->Link(sCommand, 0, NULL);

	//	Evaluate

	pOutput = m_pCC->TopLevel(pInput, &Ctx);
	pInput->Discard(m_pCC);

	//	Output result

	sOutput = m_pCC->Unlink(pOutput);
	pOutput->Discard(m_pCC);

	return sOutput;
	}

ALERROR CCore::Flush (void)

//	Flush
//
//	Flush the database

	{
	ALERROR error;
	BOOL bFlushDb = FALSE;

	ASSERT(m_pDb);

	//	Save the title indeces

	if (m_fTitleIndexModified)
		{
		if (error = SaveHeaderObject(m_pUNID2Title, &m_Header.dwUNID2TitleIndex))
			return error;

		if (error = SaveHeaderObject(m_pTitle2UNID, &m_Header.dwTitle2UNIDIndex))
			return error;

		m_fTitleIndexModified = FALSE;
		bFlushDb = TRUE;
		}

	//	Save the new categories index

	if (m_fCategoryIndexModified)
		{
		if (error = SaveHeaderObject(m_pCategoryIndex, &m_Header.dwCategoryIndex))
			return error;

		m_fCategoryIndexModified = FALSE;
		bFlushDb = TRUE;
		}

	//	Save the header

	if (m_fHeaderModified)
		{
		CString sData((char *)&m_Header, sizeof(m_Header));

		if (error = m_pDb->WriteEntry(m_pDb->GetDefaultEntry(), sData))
			return error;

		m_fHeaderModified = FALSE;
		bFlushDb = TRUE;
		}

	//	Flush the database

	if (bFlushDb)
		m_pDb->Flush();

	return NOERROR;
	}

ALERROR CCore::GetCategoryLinks (CString sCategory, CSymbolTable *pLinks)

//	GetCategoryLinks
//
//	Fills the symbol table with Titles and URLs for the entries
//	in the given category. The symbol table is responsible for
//	freeing the string.

	{
	ALERROR error;
	int i;
	CIntArray *pIndex;

	//	Find the category

	if (error = m_pCategoryIndex->Lookup(sCategory, (CObject **)&pIndex))
		return error;

	//	Create a sorted list of entry titles in this category

	for (i = 0; i < pIndex->GetCount(); i++)
		{
		CString sTitle = GetEntryTitle(pIndex->GetElement(i));
		CString *pURL = new CString(MakeURLFromUNID(pIndex->GetElement(i)));

		if (error = pLinks->AddEntry(sTitle, pURL))
			return error;
		}

	return NOERROR;
	}

CString CCore::GetEntryTitle (ENTRYUNID dwUNID)

//	GetEntryTitle
//
//	Returns the title of the given entry

	{
	ALERROR error;
	CString *pTitle;

	if (error = m_pUNID2Title->Lookup(dwUNID, (CObject **)&pTitle))
		return LITERAL("ERROR");

	return *pTitle;
	}

ALERROR CCore::LoadCategory (CString sData, CEntry **retpEntry)

//	LoadCategory
//
//	Loads an entry containing links to all the entries that
//	are part of the given category

	{
	ALERROR error;
	CCategory *pCategory;
	CEntry *pEntry;

	//	First we lookup the category in our category list.

	if (m_pCategoryList->Lookup(sData, (CObject **)&pCategory) != NOERROR)
		pCategory = NULL;

	//	If the category exists in our list then get the index
	//	from that

	if (pCategory)
		{
		if (error = LoadEntry(pCategory->GetIndexURL(), &pEntry))
			return error;
		}

	//	Otherwise we create a generated index

	else
		{
		//	Allocate a new entry

		pEntry = new CEntry(this);
		if (pEntry == NULL)
			return ERR_FAIL;

		//	Set basic information

		pEntry->SetTitle(sData);
		pEntry->SetUNID(CategoriesUNID);
		pEntry->SetCreation();

		//	The body is a simple links tag

		pEntry->SetBody(strPatternSubst(LITERAL("<LINKS category=\"%s\"/>"), sData));
			
		//	This entry is not persistent and cannot be edited

		pEntry->SetEphemeral();
		}

	//	Done

	*retpEntry = pEntry;

	return NOERROR;
	}

ALERROR CCore::LoadCategoryList (CEntry **retpEntry)

//	LoadCategoryList
//
//	Loads an entry containing links to all the categories

	{
	ALERROR error;
	CEntry *pEntry;

	//	Allocate a new entry

	pEntry = new CEntry(this);
	if (pEntry == NULL)
		return ERR_FAIL;

	//	Set basic information

	pEntry->SetTitle(LITERAL("Contents"));
	pEntry->SetUNID(CategoriesUNID);
	pEntry->SetCreation();

	//	Now create the index information

	CMemoryWriteStream Output;

	if (error = Output.Create())
		{
		delete pEntry;
		return error;
		}

	//	Put it all inside a list so that we don't get the
	//	Body style

	if (error = Output.Write("<LIST type=\"3\">", 15, NULL))
		return error;

	//	Append each entry in the categories index

	int i;
	for (i = 0; i < m_pCategoryIndex->GetCount(); i++)
		{
		CString sTitle;
		int iLen;
		char szBuffer[1024];

		sTitle = m_pCategoryIndex->GetKey(i);

		//	Do not include system categories

		if (IsSystemCategory(sTitle))
			continue;

		//	Do not include sub-categories

		if (strFind(sTitle, LITERAL("/")) != -1)
			continue;

		//	Append

		iLen = wsprintf(szBuffer, "<A href=\"core://category/%s\">%s</A><BR>",
				sTitle.GetASCIIZPointer(),
				sTitle.GetASCIIZPointer());

		if (error = Output.Write(szBuffer, iLen, NULL))
			{
			delete pEntry;
			return error;
			}
		}

	//	Close list

	if (error = Output.Write("</LIST>", 7, NULL))
		return error;

	//	Done with body

	if (error = Output.Close())
		{
		delete pEntry;
		return error;
		}

	pEntry->SetBody(CString(Output.GetPointer(), Output.GetLength()));

	//	This entry is not persistent and cannot be edited

	pEntry->SetEphemeral();

	//	Done

	*retpEntry = pEntry;

	return NOERROR;
	}

ALERROR CCore::LoadEntry (CString sURL, CEntry **retpEntry)

//	LoadEntry
//
//	Resolves an URL into an entry
//
//	The following formats are supported
//
//	core://all						-> a list of all documents
//	core://categories				-> a list of all categories
//	core://category/xxxx			-> a list of all documents of category xxxx
//	core://create/nnnn				-> where nnnn is an UNID of the entry generator
//	core://entry/nnnn				-> where nnnn is an UNID
//	core://home						-> home page (first entry of "Home" category)

	{
	ALERROR error;
	CString sTopLevel;
	CString sData;

	//	Blank URLs always return a NULL entry

	if (sURL.IsBlank())
		{
		*retpEntry = NULL;
		return NOERROR;
		}

	//	Parse the URL

	if (error = ParseCoreURL(sURL, &sTopLevel, &sData))
		return error;

	//	Handle each case

	if (strCompare(sTopLevel, LITERAL("entry")) == 0)
		error = LoadEntryByUNID(strToInt(sData, UndefinedUNID, NULL), retpEntry);
	else if (strCompare(sTopLevel, LITERAL("all")) == 0)
		error = LoadIndexEntry(retpEntry);
	else if (strCompare(sTopLevel, LITERAL("category")) == 0)
		error = LoadCategory(sData, retpEntry);
	else if (strCompare(sTopLevel, LITERAL("categories")) == 0)
		error = LoadCategoryList(retpEntry);
	else if (strCompare(sTopLevel, LITERAL("create")) == 0)
		error = CreateGeneratedEntry(strToInt(sData, UndefinedUNID, NULL), retpEntry);
	else if (strCompare(sTopLevel, LITERAL("home")) == 0)
		error = LoadHome(retpEntry);
	else
		return ERR_FAIL;

	if (error)
		return error;

	return NOERROR;
	}

ALERROR CCore::LoadEntryByUNID (ENTRYUNID dwUNID, CEntry **retpEntry)

//	LoadEntryByUNID
//
//	Load a entry from the database

	{
	ALERROR error;
	CString sError;

	//	Handle special UNIDs

	if (dwUNID == AllEntriesUNID)
		return LoadIndexEntry(retpEntry);
	else if (dwUNID == CategoriesUNID)
		return LoadCategoryList(retpEntry);

	//	Load the entry from the database

	CString sXML;
	if (error = m_pDb->ReadEntry((int)dwUNID, &sXML))
		return error;

	//	Create an entry

	if (error = CEntry::LoadFromXML(this, sXML, retpEntry, &sError))
		return error;

	//	Remember the entry ID

	(*retpEntry)->SetUNID(dwUNID);

	return NOERROR;
	}

ALERROR CCore::LoadHome (CEntry **retpEntry)

//	LoadHome
//
//	Loads the first entry of the "Home" category

	{
	ALERROR error;
	CIntArray *pIndex;

	//	Find the "Home" category

	if (error = m_pCategoryIndex->Lookup(LITERAL("Home"), (CObject **)&pIndex))
		return error;

	//	Get the first entry

	if (pIndex->GetCount() == 0)
		return ERR_FAIL;

	return LoadEntryByUNID((ENTRYUNID)pIndex->GetElement(0), retpEntry);
	}

ALERROR CCore::LoadIndexEntry (CEntry **retpEntry)

//	LoadIndexEntry
//
//	Create an index page entry

	{
	ALERROR error;
	CEntry *pEntry;

	//	Allocate a new entry

	pEntry = new CEntry(this);
	if (pEntry == NULL)
		return ERR_FAIL;

	//	Set basic information

	pEntry->SetTitle(LITERAL("Index"));
	pEntry->SetUNID(AllEntriesUNID);
	pEntry->SetCreation();

	//	Now create the index information

	CMemoryWriteStream Output;

	if (error = Output.Create())
		{
		delete pEntry;
		return error;
		}

	//	Put it all inside a list so that we don't get the
	//	Body style

	if (error = Output.Write("<LIST type=\"3\">", 15, NULL))
		return error;

	//	Append each entry in the title index

	int i;
	for (i = 0; i < m_pTitle2UNID->GetCount(); i++)
		{
		CString sTitle;
		DWORD dwUNID;
		int iLen;
		char szBuffer[1024];

		sTitle = m_pTitle2UNID->GetKey(i);
		sTitle = Deuniquify(sTitle, NULL);
		dwUNID = (DWORD)m_pTitle2UNID->GetValue(i);

		//	Append

		iLen = wsprintf(szBuffer, "<A href=\"core://entry/%d\">%s</A>",
				dwUNID,
				sTitle.GetASCIIZPointer());

		if (error = Output.Write(szBuffer, iLen, NULL))
			{
			delete pEntry;
			return error;
			}

		//	Append an entry number

		iLen = wsprintf(szBuffer, "   %d<BR>", dwUNID);
		if (error = Output.Write(szBuffer, iLen, NULL))
			{
			delete pEntry;
			return error;
			}
		}

	//	Close list

	if (error = Output.Write("</LIST>", 7, NULL))
		return error;

	//	Done with body

	if (error = Output.Close())
		{
		delete pEntry;
		return error;
		}

	pEntry->SetBody(CString(Output.GetPointer(), Output.GetLength()));

	//	This entry is not persistent and cannot be edited

	pEntry->SetEphemeral();

	//	Done

	*retpEntry = pEntry;

	return NOERROR;
	}

CString CCore::MakeURLFromUNID (ENTRYUNID dwUNID)

//	MakeURLFromUNID
//
//	Returns an URL that points to the given UNID

	{
	return strPatternSubst(LITERAL("core://entry/%d"), dwUNID);
	}

ALERROR CCore::Open (CString sFilename)

//	Open
//
//	Open a database

	{
	ALERROR error;
	CString sHeader;
	CString sData;

	ASSERT(m_pDb == NULL);

	//	Open the datafile

	m_pDb = new CDataFile(sFilename);
	if (m_pDb == NULL)
		return ERR_MEMORY;

	if (error = m_pDb->Open())
		goto Fail;

	//	Boot the codechain processor

	m_pCC = new CCodeChain;
	if (m_pCC == NULL)
		goto Fail;

	if (error = m_pCC->Boot())
		goto Fail;

	if (error = RegisterPrimitives())
		goto Fail;

	//	Load the header

	if (error = m_pDb->ReadEntry(m_pDb->GetDefaultEntry(), &sHeader))
		goto Fail;

	m_Header = *(COREHEADER *)sHeader.GetPointer();
	if (m_Header.dwSignature != CORE_SIGNATURE)
		{
		error = ERR_FILEOPEN;
		goto Fail;
		}

	if (m_Header.dwVersion > CORE_VERSION)
		{
		error = ERR_FILEOPEN;
		goto Fail;
		}

	//	Load the UNID2Title index

	if (m_Header.dwUNID2TitleIndex)
		{
		if (error = m_pDb->ReadEntry(m_Header.dwUNID2TitleIndex, &sData))
			goto Fail;

		if (error = CObject::Unflatten(sData, (CObject **)&m_pUNID2Title))
			goto Fail;
		}
	else
		{
		m_pUNID2Title = new CIDTable(TRUE, FALSE);
		if (m_pUNID2Title == NULL)
			{
			error = ERR_MEMORY;
			goto Fail;
			}
		}

	//	Load the Title2UNID index

	if (m_Header.dwTitle2UNIDIndex)
		{
		if (error = m_pDb->ReadEntry(m_Header.dwTitle2UNIDIndex, &sData))
			goto Fail;

		if (error = CObject::Unflatten(sData, (CObject **)&m_pTitle2UNID))
			goto Fail;
		}
	else
		{
		m_pTitle2UNID = new CSymbolTable(FALSE, TRUE);
		if (m_pTitle2UNID == NULL)
			{
			error = ERR_MEMORY;
			goto Fail;
			}
		}

	//	Load the category index

	if (m_Header.dwCategoryIndex)
		{
		if (error = m_pDb->ReadEntry(m_Header.dwCategoryIndex, &sData))
			goto Fail;

		if (error = CObject::Unflatten(sData, (CObject **)&m_pCategoryIndex))
			goto Fail;
		}
	else
		{
		m_pCategoryIndex = new CSymbolTable(TRUE, FALSE);
		if (m_pCategoryIndex == NULL)
			{
			error = ERR_MEMORY;
			goto Fail;
			}
		}

	//	Update the list of custom categories

	if (error = UpdateCategoryList())
		goto Fail;

	return NOERROR;

Fail:

	if (m_pDb)
		{
		m_pDb->Close();
		delete m_pDb;
		m_pDb = NULL;

		if (m_pUNID2Title)
			{
			delete m_pUNID2Title;
			m_pUNID2Title = NULL;
			}

		if (m_pTitle2UNID)
			{
			delete m_pTitle2UNID;
			m_pTitle2UNID = NULL;
			}

		if (m_pCategoryIndex)
			{
			delete m_pCategoryIndex;
			m_pCategoryIndex = NULL;
			}

		if (m_pCC)
			{
			delete m_pCC;
			m_pCC = NULL;
			}
		}

	return error;
	}

ALERROR CCore::ParseCoreURL (CString sURL, CString *retsTopLevel, CString *retsData)

//	ParseCoreURL
//
//	Parse a core:// URL

	{
	char *pPos;
	char *pStart;

	pStart = sURL.GetASCIIZPointer();
	pPos = pStart;

	//	Look for the colon

	while (*pPos != ':' && *pPos != '\0')
		pPos++;

	if (*pPos != ':')
		return ERR_FAIL;

	CString sProtocol(pStart, pPos - pStart);
	if (strCompare(sProtocol, LITERAL("core")) != 0)
		return ERR_FAIL;

	pPos++;

	//	Next char better be a slash

	if (*pPos != '/')
		return ERR_FAIL;

	pPos++;

	//	Next char also better be a slash

	if (*pPos != '/')
		return ERR_FAIL;

	pPos++;

	//	Parse the top level name

	pStart = pPos;
	while (*pPos != '/' && *pPos != '\0')
		pPos++;

	*retsTopLevel = CString(pStart, pPos - pStart);

	//	If there is more, parse the data

	if (*pPos == '/')
		{
		pPos++;

		*retsData = CString(pPos);
		}

	return NOERROR;
	}

ICCItem *CCore::RunEntryCode (CEntry *pEntry, CString sCode, ICCItem *pArg1, ICCItem *pArg2, ICCItem *pArg3)

//	RunEntryCode
//
//	Runs code bound to an entry

	{
	ALERROR error;
	ICCItem *pCode;
	ICCItem *pResult;
	CCLinkedList *pCall;
	COREEXECCTX Ctx;

	//	First get the code from the entry
	//	Note that the item that we get back from GetCode is owned
	//	by the entry, so we should not discard it.

	if (error = pEntry->GetCode(sCode, &pCode))
		{
		//	It's OK if we can't find the code; it just means that we
		//	have nothing to execute.
		return m_pCC->CreateNil();
		}

	//	Create a list to hold the call

	pResult = m_pCC->CreateLinkedList();
	if (pResult->IsError())
		{
		pCode->Discard(m_pCC);
		return pResult;
		}

	pCall = (CCLinkedList *)pResult;

	//	Add the function

	pCall->Append(m_pCC, pCode, NULL);

	//	Add some arguments

	if (pArg1)
		pCall->Append(m_pCC, pArg1, NULL);

	if (pArg2)
		pCall->Append(m_pCC, pArg2, NULL);

	if (pArg3)
		pCall->Append(m_pCC, pArg3, NULL);

	//	Setup context

	Ctx.pCore = this;

	//	Execute

	pResult = m_pCC->TopLevel(pCall, &Ctx);
	pCall->Discard(m_pCC);

	//	Done

	return pResult;
	}

ALERROR CCore::SaveEntry (CEntry *pEntry)

//	SaveEntry
//
//	Saves the entry

	{
	ALERROR error;

	//	Set the modification time

	pEntry->SetModification();

	//	Convert to XML

	CString sXML;
	if (error = CEntry::SaveToXML(pEntry, &sXML))
		return error;

	//	Save

	if (error = m_pDb->WriteEntry((int)pEntry->GetUNID(), sXML))
		return error;

	//	Update the index

	UpdateCategoryIndex(pEntry, TRUE);
	UpdateTitleIndex(pEntry);

	//	Flush. Note that for efficiency we should do this on
	//	a background thread. For now, though, we do it synchronously.

	if (error = Flush())
		return error;

	return NOERROR;
	}

ALERROR CCore::SaveHeaderObject (CObject *pObject, DWORD *iodwUNID)

//	SaveHeaderObject
//
//	Saves a meta data object kept in the header

	{
	ALERROR error;
	CString sData;

	if (error = CObject::Flatten(pObject, &sData))
		return error;

	if (*iodwUNID != 0)
		{
		if (error = m_pDb->WriteEntry(*iodwUNID, sData))
			return error;
		}
	else
		{
		if (error = m_pDb->AddEntry(sData, (int *)iodwUNID))
			return error;

		m_fHeaderModified = TRUE;
		}

	return NOERROR;
	}

CString CCore::Uniquify (CString sText, ENTRYUNID dwUNID)

//	Uniquify
//
//	Takes a string and appends an UNID so that the string is
//	unique for a given UNID. This is used for the title index to
//	allow multiple entries to have the same title

	{
	return strPatternSubst(LITERAL("%s<%d>"), sText, dwUNID);
	}

ALERROR CCore::UpdateCategoryIndex (CEntry *pEntry, BOOL bRemoveOldCategories)

//	UpdateCategoryIndex
//
//	Updates the category index

	{
	ALERROR error;
	CStringArray CategoriesToAdd;
	int i;
	BOOL bCategoryListModified = FALSE;

	//	Create a list of categories to add

	CategoriesToAdd = pEntry->GetCategories();

	//	An entry with no categories is always in the Miscellaneous category

	if (CategoriesToAdd.GetCount() == 0)
		{
		if (error = CategoriesToAdd.AppendString(LITERAL("Miscellaneous"), NULL))
			return error;
		}
	else if (CategoriesToAdd.GetCount() == 1 && CategoriesToAdd.GetStringValue(0).IsBlank())
		{
		if (error = CategoriesToAdd.SetStringValue(0, LITERAL("Miscellaneous")))
			return error;
		}

	//	Figure out which old categories we were in

	if (bRemoveOldCategories)
		{
		//	Loop over all categories to see which categories we appear in

		for (i = 0; i < m_pCategoryIndex->GetCount(); i++)
			{
			CIntArray *pIndex = (CIntArray *)m_pCategoryIndex->GetValue(i);
			int iPos;

			iPos = pIndex->FindElement(pEntry->GetUNID());
			if (iPos != -1)
				{
				int iCatPos;

				//	Figure out if this category is in the list of categories
				//	to add. If so, then we no longer need to add it. If not,
				//	then we need to remove it

				iCatPos = CategoriesToAdd.FindString(m_pCategoryIndex->GetKey(i));
				if (iCatPos != -1)
					{
					if (error = CategoriesToAdd.RemoveString(iCatPos))
						return error;
					}
				else
					{
					//	If this category is the list of system categories then
					//	we remember to update the list.

					if (strCompare(m_pCategoryIndex->GetKey(i), CONSTLIT(g_szSysCatCategory)) == 0)
						bCategoryListModified = TRUE;

					//	Remove this entry from the index

					if (error = pIndex->RemoveElement(iPos))
						return error;

					//	If this index has no more entries, then we remove
					//	the entire category

					if (pIndex->GetCount() == 0)
						{
						m_pCategoryIndex->RemoveEntry(m_pCategoryIndex->GetKey(i), NULL);

						//	Since we're deleting an entry, we have to adjust
						//	our loop counter

						i--;
						}

					m_fCategoryIndexModified = TRUE;
					}
				}
			}
		}

	//	Now add ourselves for each category

	for (i = 0; i < CategoriesToAdd.GetCount(); i++)
		{
		CIntArray *pIndex;

		//	If this category is the list of system categories then
		//	we remember to update the list.

		if (strCompare(CategoriesToAdd.GetStringValue(i), CONSTLIT(g_szSysCatCategory)) == 0)
			bCategoryListModified = TRUE;

		//	Add the entry

		if (error = m_pCategoryIndex->Lookup(CategoriesToAdd.GetStringValue(i), (CObject **)&pIndex))
			{
			//	If we could not find this category, then add a new array

			if (error == ERR_NOTFOUND)
				{
				pIndex = new CIntArray;
				if (pIndex == NULL)
					return ERR_MEMORY;

				if (error = m_pCategoryIndex->AddEntry(CategoriesToAdd.GetStringValue(i), pIndex))
					{
					delete pIndex;
					return error;
					}
				}
			else
				return error;
			}

		//	Add our UNID to the index

		if (error = pIndex->AppendElement(pEntry->GetUNID(), NULL))
			return error;

		m_fCategoryIndexModified = TRUE;
		}

	//	Update the category list, if necessary

	if (bCategoryListModified)
		UpdateCategoryList();

	return NOERROR;
	}

ALERROR CCore::UpdateCategoryList (void)

//	UpdateCategoryList
//
//	Builds a list of custom categories (entries with the $Category category).
//	and loads them as CCategory objects indexed by category name

	{
	ALERROR error;
	CSymbolTable CustomCategoryURLs(TRUE, FALSE);
	CSymbolTable *pCategoryList;

	//	Get the list of all custom categories

	if (error = GetCategoryLinks(CONSTLIT(g_szSysCatCategory), &CustomCategoryURLs))
		{
		//	We ignore this error because sometimes we don't have any entries
		//	of this category. We continue assuming that CustomCategoryURLs is
		//	empty.
		}

	//	Create a new category list

	pCategoryList = new CSymbolTable(TRUE, FALSE);
	if (pCategoryList == NULL)
		return ERR_MEMORY;

	//	Look over each custom category

	for (int i = 0; i < CustomCategoryURLs.GetCount(); i++)
		{
		CString sURL = *(CString *)CustomCategoryURLs.GetValue(i);
		CEntry *pEntry;
		CCategory *pCategory;

		//	Load the entry

		if (error = LoadEntry(sURL, &pEntry))
			{
			delete pCategoryList;
			return error;
			}

		//	Create a new category from the entry

		error = CCategory::LoadFromEntry(pEntry, &pCategory);
		delete pEntry;
		if (error)
			{
			delete pCategoryList;

			//	We ignore this error because it is possible for the
			//	user to screw up the definition of the category entry.
			//	In that case we just continue to the next entry.

			continue;
			}

		//	Add the category to our list

		if (error = pCategoryList->AddEntry(pCategory->GetCategory(), pCategory))
			{
			delete pCategoryList;
			return error;
			}
		}

	//	Replace the old category list

	if (m_pCategoryList)
		delete m_pCategoryList;

	m_pCategoryList = pCategoryList;

	return NOERROR;
	}

ALERROR CCore::UpdateTitleIndex (CEntry *pEntry)

//	UpdateTitleIndex
//
//	Updates the index of titles

	{
	ALERROR error;
	CString *pOldTitle;

	//	Replace or add the UNID to Title index

	if (error = m_pUNID2Title->ReplaceEntry(pEntry->GetUNID(),
			new CString(pEntry->GetTitle()),
			TRUE,
			(CObject **)&pOldTitle))
		return error;

	//	If the old title is different, update the other index too

	if (pOldTitle == NULL || strCompare(*pOldTitle, pEntry->GetTitle()) != 0)
		{
		//	Delete the old title, if necessary

		if (pOldTitle)
			{
			if (error = m_pTitle2UNID->RemoveEntry(Uniquify(*pOldTitle, pEntry->GetUNID()), NULL))
				return error;
			}

		//	Add a new title

		if (error = m_pTitle2UNID->AddEntry(Uniquify(pEntry->GetTitle(), pEntry->GetUNID()),
				(CObject *)pEntry->GetUNID()))
			return error;

		m_fTitleIndexModified = TRUE;
		}

	if (pOldTitle)
		delete pOldTitle;

	return NOERROR;
	}
